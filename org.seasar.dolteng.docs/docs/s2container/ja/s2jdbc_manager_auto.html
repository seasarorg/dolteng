<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">










<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
<meta http-equiv="Content-Language" content="ja" /> 
<meta http-equiv="Content-Style-Type" content="text/css" /> 
<title>Seasar2 - S2JDBC - JdbcManager - SQL自動生成による操作</title>
<link rel="stylesheet" type="text/css" href="http://www.seasar.org/theme/main.css" media="screen,projection" />
<link rel="stylesheet" type="text/css" href="http://www.seasar.org/theme/print.css" media="print" />
<link href="./css/maven-base.css" type="text/css" rel="stylesheet" media="screen" />
<link href="./css/maven-theme.css" type="text/css" rel="stylesheet" media="screen" />
</head>

<body>

<div id="wrapper">

<div id="header">

<div class="line"><span class="hide">spacer</span></div>

<div id="logo"><h1 id="h01" class="hide">The Seasar Foundation Project Site</h1><img src="http://www.seasar.org/images/seasar_logo_blue.gif" alt="The Seasar Foundation" width="390" height="180" /></div>

<div id="tool">

<h2><a href="http://search.seasar.org/">Site Search</a></h2>

<form id="search" action="http://search.seasar.org/">
<div>
	<input id="search_phrase" type="text" name="phrase" size="20" />
	<input type="hidden" name="perpage" value="30" />
	<input type="hidden" name="enc" value="UTF-8" />
	<input id="search_go" type="submit" value="Search" />
</div>
</form>

<h2>Seasar Banner</h2>

<p><a href="http://www.seasar.org/images/seasar_banner.gif"><img src="http://www.seasar.org/images/seasar_banner.gif" alt="Seasar Banner" title="Seasar Banner" width="146" height="33" /></a></p>

</div>

<div id="navi">
<p><a href="../en/">English</a> | <a href="../ja/">Japanese</a></p>
</div>

</div><!-- header -->

<div id="contents_left">
           
  

  
    
  
  
                   <h2>About</h2>
        <ul>
              
    <li class="none">
              <a href="index.html">ホーム</a>
        </li>
              
    <li class="none">
              <a href="license.html">ライセンス</a>
        </li>
              
    <li class="none">
              <a href="downloads.html">ダウンロード</a>
        </li>
              
    <li class="none">
              <a href="http://www.seasar.org/wiki/index.php?ChangeLog%2FSeasar">ChangeLog</a>
        </li>
              
    <li class="none">
              <a href="http://www.seasar.org/wiki/index.php?SeasarUpdateOperationLog">移行ガイド</a>
        </li>
          </ul>
          <h2>ドキュメント</h2>
        <ul>
              
    <li class="none">
              <a href="documents.html">一覧</a>
        </li>
              
    <li class="none">
              <a href="setup.html">セットアップ</a>
        </li>
              
    <li class="none">
              <a href="DIContainer.html">DIContainer</a>
        </li>
              
    <li class="none">
              <a href="aop.html">AOP</a>
        </li>
              
                
              
      
            
      
            
      
            
      
            
      
            
            
            
      
            
      
                  
      
              
            <li class="expanded">
              <a href="s2jdbc.html">S2JDBC</a>
                <ul>
                  
    <li class="none">
              <a href="s2jdbc_abstract.html">S2JDBCとは</a>
        </li>
                  
    <li class="none">
              <a href="s2jdbc_tutorial.html">チュートリアル</a>
        </li>
                  
    <li class="none">
              <a href="s2jdbc_setup.html">セットアップ</a>
        </li>
                  
    <li class="none">
              <a href="s2jdbc_entity.html">エンティティ</a>
        </li>
                  
                
              
            
            
      
            
      
              
            <li class="expanded">
              <a href="s2jdbc_manager.html">JdbcManager</a>
                <ul>
                  
    <li class="none">
              <strong>SQL自動生成による操作</strong>
        </li>
                  
    <li class="none">
              <a href="s2jdbc_manager_sql.html">SQLによる操作</a>
        </li>
                  
    <li class="none">
              <a href="s2jdbc_manager_sqlfile.html">SQLファイルによる操作</a>
        </li>
              </ul>
        </li>
                  
    <li class="none">
              <a href="s2jdbc_other.html">その他の機能</a>
        </li>
              </ul>
        </li>
              
    <li class="none">
              <a href="http://www.seasar.org/wiki/index.php?FAQ%2FS2Container">FAQ (全般)</a>
        </li>
              
    <li class="none">
              <a href="http://www.seasar.org/wiki/index.php?FAQ%2FS2AOP">FAQ (AOP)</a>
        </li>
          </ul>
          <h2>Javadoc</h2>
        <ul>
              
    <li class="none">
              <a href="../s2-framework/ja/apidocs/index.html">S2-Framework</a>
        </li>
              
    <li class="none">
              <a href="../s2-extension/ja/apidocs/index.html">S2-Extension</a>
        </li>
              
    <li class="none">
              <a href="../s2-tiger/ja/apidocs/index.html">S2-Tiger</a>
        </li>
          </ul>
          <h2>モジュール</h2>
        <ul>
              
    <li class="none">
              <a href="index.html">Seasar2</a>
        </li>
              
    <li class="none">
              <a href="../s2-framework/ja/index.html">S2-Framework</a>
        </li>
              
    <li class="none">
              <a href="../s2-extension/ja/index.html">S2-Extension</a>
        </li>
              
    <li class="none">
              <a href="../s2-tiger/ja/index.html">S2-Tiger</a>
        </li>
          </ul>
          <h2>プロジェクト文書</h2>
        <ul>
              
                
              
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
              
        <li class="collapsed">
              <a href="project-info.html">プロジェクト情報</a>
              </li>
          </ul>
                                       <a href="http://maven.apache.org/" title="Built by Maven" id="poweredBy" name="poweredBy">
            <img alt="Built by Maven" src="./images/logos/maven-feather.png" />
          </a>
                       
  

  
    
  
  
  </div><!-- contents_left -->

<div id="contents_center">

<div id="article">
<div class="section"><h2><a name="SQL自動生成による操作"></a>
SQL自動生成による操作</h2>
<ul><li><a href="#検索">検索</a>
<ul><li><a href="#複数件検索">複数件検索</a>
</li>
<li><a href="#1件検索">1件検索</a>
</li>
<li><a href="#イテレーションによる検索">イテレーションによる検索</a>
</li>
<li><a href="#検索結果の行数取得">検索結果の行数取得</a>
</li>
<li><a href="#結合">結合</a>
<ul><li><a href="#結合条件の追加">
												結合条件の追加
											</a>
</li>
<li><a href="#結合のネスト">結合のネスト</a>
</li>
</ul>
</p>
</li>
<li><a href="#検索条件">検索条件</a>
<ul><li><a href="#IDとバージョンによる指定">
												IDとバージョンによる指定
											</a>
</li>
<li><a href="#SQL文字列による指定">
												SQL文字列による指定
											</a>
</li>
<li><a href="#SimpleWhereによる指定">
												SimpleWhereによる指定
											</a>
</li>
<li><a href="#Mapによる指定">
												Mapによる指定
											</a>
</li>
</ul>
</p>
</li>
<li><a href="#ソート順">ソート順</a>
</li>
<li><a href="#排他制御">排他制御</a>
</li>
<li><a href="#ページング">ページング</a>
</li>
<li><a href="#最大行数">最大行数</a>
</li>
<li><a href="#フェッチサイズ">フェッチサイズ</a>
</li>
<li><a href="#クエリタイムアウト">クエリタイムアウト</a>
</li>
<li><a href="#ヒント">ヒント</a>
</li>
</ul>
</li>
<li><a href="#挿入">挿入</a>
<ul><li><a href="#1件挿入">1件挿入</a>
</li>
<li><a href="#バッチ挿入">バッチ挿入</a>
</li>
<li><a href="#nullの項目を挿入しない">
									nullの項目を挿入しない
								</a>
</li>
<li><a href="#指定したプロパティのみを挿入対象にする">
									指定したプロパティのみを挿入対象にする
								</a>
</li>
<li><a href="#指定したプロパティを挿入対象から除外する">
									指定したプロパティを挿入対象から除外する
								</a>
</li>
<li><a href="#バッチ挿入のサイズを指定する">
									バッチ挿入のサイズを指定する
								</a>
</li>
</ul>
</li>
<li><a href="#更新">更新</a>
<ul><li><a href="#1件更新">1件更新</a>
</li>
<li><a href="#バッチ更新">バッチ更新</a>
</li>
<li><a href="#バージョンプロパティを通常の更新対象にする">
									バージョンプロパティを通常の更新対象にする
								</a>
</li>
<li><a href="#nullの項目を更新しない">
									nullの項目を更新しない
								</a>
</li>
<li><a href="#指定したプロパティのみを更新対象にする">
									指定したプロパティのみを更新対象にする
								</a>
</li>
<li><a href="#指定したプロパティを更新対象から除外する">
									指定したプロパティを更新対象から除外する
								</a>
</li>
<li><a href="#変更のあったプロパティのみを更新対象にする">
									変更のあったプロパティのみを更新対象にする
								</a>
</li>
<li><a href="#更新行数をチェックしない">更新行数をチェックしない</a>
</li>
<li><a href="#バッチ更新のサイズを指定する">
									バッチ更新のサイズを指定する
								</a>
</li>
</ul>
</li>
<li><a href="#削除">削除</a>
<ul><li><a href="#1件削除">1件削除</a>
</li>
<li><a href="#バッチ削除">バッチ削除</a>
</li>
<li><a href="#バージョンをチェックしないで削除する">
									バージョンをチェックしないで削除する
								</a>
</li>
<li><a href="#削除行数をチェックしない">削除行数をチェックしない</a>
</li>
<li><a href="#バッチ削除のサイズを指定する">
									バッチ削除のサイズを指定する
								</a>
</li>
</ul>
</li>
<li><a href="#ストアドの呼び出し">ストアドの呼び出し</a>
<ul><li><a href="#ストアドプロシージャの呼び出し">
									ストアドプロシージャの呼び出し
								</a>
</li>
<li><a href="#ストアドファンクションの呼び出し">
									ストアドファンクションの呼び出し
								</a>
</li>
</ul>
</li>
</ul>
</div>
<div class="section"><h2><a name="検索"></a>
検索</h2>
<div class="section"><h3><a name="複数件検索"></a>
複数件検索</h3>
<p>複数件を検索する場合は、gerResultList()を使います。</p>
<div class="source"><pre>
List&lt;Employee&gt; results = jdbcManager.from(Employee.class).getResultList();
</pre>
</div>
<p>検索するエンティティは、from()で指定します。</p>
<p>
					デフォルトでは、結果がなかった場合は、 空の
					<code>List</code>
					が返されます。
					<code>disallowNoResult()</code>
					を呼び出すと、 結果がなかった場合は
					<code>javax.persistence.NoResultException</code>
					が発生します。
				</p>
<div class="source"><pre>
List&lt;Employee&gt; results = jdbcManager.from(Employee.class)
                                    .disallowNoResult()
                                    .getResultList();
</pre>
</div>
</div>
<div class="section"><h3><a name="a1件検索"></a>
1件検索</h3>
<p>1件検索する場合は、getSingleResult()を使います。</p>
<div class="source"><pre>
Employee result = jdbcManager.from(Employee.class).getSingleResult();
</pre>
</div>
<p>
					結果が複数件になる場合は、
					<code>
						javax.persistence.NonUniqueResultException
					</code>
					が発生します。
				</p>
<div class="source"><pre>
Employee result = jdbcManager.from(Employee.class)
                             .where(&quot;id = ?&quot;, id)
                             .getSingleResult();
</pre>
</div>
<p>
					デフォルトでは、結果がなかった場合は、
					<code>null</code>
					が返されます。
					<code>disallowNoResult()</code>
					を呼び出すと、 結果がなかった場合は
					<code>javax.persistence.NoResultException</code>
					が発生します。
				</p>
<div class="source"><pre>
Employee result = jdbcManager.from(Employee.class)
                             .where(&quot;id = ?&quot;, id)
                             .disallowNoResult()
                             .getSingleResult();
</pre>
</div>
</div>
<div class="section"><h3><a name="イテレーションによる検索"></a>
イテレーションによる検索</h3>
<p>
					検索結果が多くの行を返すため、
					<code>List</code>
					でまとめて受け取ることが困難な場合は
					<code>iterate(IterationCallback)</code>
					を使います。
				</p>
<div class="source"><pre>
int count = results = jdbcManager
    .from(Employee.class)
    .iterate(new IterationCallback&lt;BeanMap, Integer&gt;() {
        int count;
        public Integer iterate(BeanMap map, IterationContext context) {
            if (...) {
                ++count;
            }
            return count;
        }
    });
</pre>
</div>
<p><code>iterate(IterationCallback)</code>
					の引数には、 次のインターフェースを実装したクラスのインスタンスを渡します。
				</p>
<ul><li><code>
								org.seasar.extension.jdbc.IterationCallback&lt;ENTITY,
								RESULT&gt;
							</code></li>
</ul>
<p><code>ENTITY</code>
					は
					<code>from()</code>
					で指定したエンティティクラス、
					<code>RESULT</code>
					は
					<code>iterate(IterationCallback)</code>
					が返す結果の型を指定します。
				</p>
<p><code>from()</code>
					で指定したエンティティ1件ごとに次のメソッドがコールバックされます。
				</p>
<ul><li><code>
								RESULT iterate(ENTITY entity,
								IterationContext context)
							</code></li>
</ul>
<p>
					コールバックメソッドが最後に返した値が
					<code>iterate(IterationCallback)</code>
					の戻り値となります。
				</p>
<p>
					コールバックメソッドの第2引数で渡される
					<code>
						org.seasar.extension.jdbc.IterationContext
					</code>
					の
					<code>exit</code>
					プロパティを
					<code>true</code>
					にすると、 問い合わせ結果のイテレーションは終了となり、 検索結果の残りは無視されます。
					その時の戻り値が
					<code>iterate(IterationCallback)</code>
					の戻り値となります。
				</p>
<p>
					1対多関連を
					<a href="#結合">結合</a>

					する場合は、
					<code>from()</code>
					で指定したエンティティで
					<a href="#ソート順">ソート</a>

					して、結果セットが次のような順になるようにします。
				</p>
<table class="bodyTable"><tr class="a"><th><code>from()</code>
							で指定したエンティティ
						</th>
<th>結合したエンティティ</th>
</tr>
<tr class="b"><td>A1</td>
<td>B1</td>
</tr>
<tr class="a"><td>A1</td>
<td>B2</td>
</tr>
<tr class="b"><td>A2</td>
<td>B1</td>
</tr>
<tr class="a"><td>A2</td>
<td>B2</td>
</tr>
</table>
<p>
					上記のような結果セットの場合、 コールバックメソッドはA1とA2が1回ずつ、 計2回呼び出されます。
					A1に関連づけられたB1およびB2のインスタンスと、
					A2に関連づけられたB1およびB2のインスタンスは異なります(同じ値を持つが同一ではない)。
				</p>
<table class="bodyTable"><tr class="b"><th><code>from()</code>
							で指定したエンティティ
						</th>
<th>結合したエンティティ</th>
</tr>
<tr class="a"><td>A1</td>
<td>B1</td>
</tr>
<tr class="b"><td>A2</td>
<td>B1</td>
</tr>
<tr class="a"><td>A1</td>
<td>B2</td>
</tr>
<tr class="b"><td>A2</td>
<td>B2</td>
</tr>
</table>
<p>結果セットが上記のような順になっている場合、 コールバックメソッドは4回呼び出されてしまいます。</p>
</div>
<div class="section"><h3><a name="検索結果の行数取得"></a>
検索結果の行数取得</h3>
<p>
					SELECT COUNT(*) ～による検索結果の行数を取得する場合は、getCount()を使います。
				</p>
<div class="source"><pre>
long count = jdbcManager.from(Employee.class).getCount();
</pre>
</div>
<p><code>getCount()</code>
					が返す値は問い合わせ結果の行数であり、 同等の問い合わせを行った場合に
					<a href="#複数件検索"><code>getResultList()</code></a>

					が返すエンティティの数と一致するとは限りません。
					<code>from()</code>
					で指定したエンティティに
					<a href="s2jdbc_entity.html#一対多関連定義">1対多関連</a>

					を
					<a href="#結合">結合</a>

					した場合、
					<code>getCount()</code>
					が返す行数は
					<code>getResultList()</code>
					が返すエンティティの数よりも多くなる場合があります。
				</p>
</div>
<div class="section"><h3><a name="結合"></a>
結合</h3>
<p>他のエンティティを結合する場合は、次のメソッドを使用します。</p>
<ul><li><code>innerJoin(String name)</code></li>
<li><code>
								innerJoin(String name, boolean fetch)
							</code></li>
<li><code>leftOuterJoin(String name)</code></li>
<li><code>
								leftOuterJoin(String name, boolean
								fetch)
							</code></li>
</ul>
<p>第1引数は、結合したいエンティティのプロパティ名です。</p>
<div class="source"><pre>
List&lt;Employee&gt; results = jdbcManager.from(Employee.class)
                                    .innerJoin(&quot;department&quot;).getResultList();
</pre>
</div>
<p>次のように外部結合にすることもできます。</p>
<div class="source"><pre>
List&lt;Employee&gt; results = jdbcManager.from(Employee.class)
                                    .leftOuterJoin(&quot;department&quot;).getResultList();
</pre>
</div>
<p>検索条件には含めたいけど、検索結果には含めたくない場合、 2番名の引数をfalseにします。</p>
<div class="source"><pre>
List&lt;Employee&gt; results = jdbcManager.from(Employee.class)
                                    .innerJoin(&quot;department&quot;, false)
                                    .where(&quot;department.name = 'RESEARCH'&quot;)
                                    .getResultList();
</pre>
</div>
<h4><a name="結合条件の追加">結合条件の追加</a>
</h4>
<p>追加の結合条件を指定することもできます。</p>
<p>追加の結合条件をSQL文字列で指定する場合は、次のメソッドを使用します。</p>
<ul><li><code>
								innerJoin(String name, String condition,
								Object... params)
							</code></li>
<li><code>
								innerJoin(String name, boolean fetch,
								String condition, Object... params)
							</code></li>
<li><code>
								leftOuterJoin(String name, String
								condition, Object... params)
							</code></li>
<li><code>
								leftOuterJoin(String name, boolean
								fetch, String condition, Object...
								params)
							</code></li>
</ul>
<p>
					引数
					<code>condition</code>
					に指定できる条件は、SQLと同じです。 SQLとの違いは、カラム名の代わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、innerJoin()/leftOuterJoin()で指定した名前.
					プロパティ名になります。
				</p>
<div class="source"><pre>
List&lt;Department&gt; results = jdbcManager.from(Department.class)
                                    .leftOuterJoin(&quot;employee&quot;, &quot;employee.salary &gt; ?&quot;, 1000)
                                    .getResultList();
</pre>
</div>
<p>
					指定方法の詳細は「
					<a href="#SQL文字列による指定">SQL文字列による指定</a>

					」を参照してください。
				</p>
<p>
					追加の結合条件を
					<code>SimpleWhere</code>
					で指定する場合は、次のメソッドを使用します。
				</p>
<ul><li><code>
								innerJoin(String name, Where condition)
							</code></li>
<li><code>
								innerJoin(String name, boolean fetch,
								Where condition)
							</code></li>
<li><code>
								leftOuterJoin(String name, Where
								condition)
							</code></li>
<li><code>
								leftOuterJoin(String name, boolean
								fetch, Where condition)
							</code></li>
</ul>
<div class="source"><pre>
List&lt;Department&gt; results = jdbcManager.from(Department.class)
                                    .leftOuterJoin(&quot;employee&quot;, 
                                        new SimpleWhere().gt(&quot;employee.salary&quot;, 1000))
                                    .getResultList();
</pre>
</div>
<p>
					指定方法の詳細は「
					<a href="#SimpleWhereによる指定">SimpleWhereによる指定</a>

					」を参照してください。
				</p>
<h4><a name="結合のネスト">結合のネスト</a>
</h4>
<p>
					結合は、employee.addressのようにネストすることもできます。
					ネストする場合は、必ずベースとなる結合を先に指定します。
					employee.addressの場合、employeeがベースとなる結合です。
				</p>
<div class="source"><pre>
List&lt;Department&gt; results = jdbcManager.from(Department.class)
                                    .leftOuterJoin(&quot;employee&quot;)
                                    .leftOuterJoin(&quot;employee.address&quot;)
                                    .getResultList();
</pre>
</div>
<p>結合は、多対一関連、一対多関連、一対一関連のどれでも可能で、 いくつでもネストすることが可能です。</p>
</div>
<div class="section"><h3><a name="検索条件"></a>
検索条件</h3>
<h4><a name="IDとバージョンによる指定">IDとバージョンによる指定</a>
</h4>
<p>
					IDプロパティ (主キー) を指定して検索対象を指定する場合は、
					<code>id(Object...)</code>
					を使います。 引数はエンティティに定義されたIDプロパティと同じ数・同じ並びで指定します。
				</p>
<div class="source"><pre>
jdbcManager.from(Department.class)
    .id(100)
    .getSingleResult();
</pre>
</div>
<p>
					IDと同時にバージョンを指定することもできます。 バージョンプロパティを指定する場合は、
					<code>version(Object)</code>
					を使います。
				</p>
<div class="source"><pre>
jdbcManager.from(Department.class)
    .id(100).version(10)
    .getSingleResult();
</pre>
</div>
<p>IDを指定しないでバージョンだけを指定することはできません。</p>
<h4><a name="SQL文字列による指定">SQL文字列による指定</a>
</h4>
<p>
					より複雑な検索条件を指定する場合は、where()を使います。
					where()に書くことのできる条件は、SQLと同じです。
					SQLとの違いは、カラム名の代わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、innerJoin()/leftOuterJoin()で指定した名前.
					プロパティ名になります。
				</p>
<div class="source"><pre>
jdbcManager.from(Department.class)
    .leftOuterJoin(&quot;employeeList&quot;)
    .leftOuterJoin(&quot;employeeList.address&quot;)
    .where(&quot;employeeList.salary between ? and ? and employeeList.address.street like ?&quot;, ...)
    .getResultList();
</pre>
</div>
<p><code>java.util.Date</code>
					・
					<code>java.util.Calendar</code>
					型のパラメータを指定する場合は、時制を指定することができます。 時制の指定は
					<code>
						org.seasar.extension.jdbc.parameter.Parameter
					</code>
					のstaticメソッドを使います。
				</p>
<dl><dt><code>date(Date)</code>
						または
						<code>date(Calendar)</code></dt>
<dd>パラメータをSQL標準のDATE型 (日付のみ) として扱います。</dd>
<dt><code>time(Date)</code>
						または
						<code>time(Calendar)</code></dt>
<dd>パラメータをSQL標準のTIME型 (時刻のみ) として扱います。</dd>
<dt><code>timestamp(Date)</code>
						または
						<code>timestamp(Calendar)</code></dt>
<dd>パラメータをSQL標準のTIMESTAMP型 (日付と時刻) として扱います。</dd>
</dl>
<div class="source"><pre>
import static org.seasar.extension.jdbc.parameter.Parameter.*;

jdbcManager.from(Employee.class)
    .where(&quot;heredate = ?&quot;, date(heredate))
    .getResultList();
</pre>
</div>
<p><code>byte[]</code>
					・
					<code>String</code>
					型のパラメータを指定する場合は、ラージオブジェクトであることを指定することができます。
					ラージオブジェクトの指定は
					<code>
						org.seasar.extension.jdbc.parameter.Parameter
					</code>
					のstaticメソッドを使います。
				</p>
<dl><dt><code>lob(String)</code></dt>
<dd>パラメータをCLOBとして扱います。</dd>
<dt><code>lob(byte[])</code>
						または
						<code>lob(Serializable)</code></dt>
<dd>パラメータをBLOBとして扱います。</dd>
</dl>
<div class="source"><pre>
import static org.seasar.extension.jdbc.parameter.Parameter.*;

jdbcManager.from(Employee.class)
    .where(&quot;largeName = ?&quot;, lob(largeName))
    .getResultList();
</pre>
</div>
<h4><a name="SimpleWhereによる指定">SimpleWhereによる指定</a>
</h4>
<p>
					検索条件の入力画面などでは、ユーザの入力があった部分をandでつないで、
					条件を組み立てるということが良く行われます。 このようなケースを簡単に処理するために、
					SimpleWhereとMapでも、検索条件を指定できるようにしています。
				</p>
<p>
					名前、仕事タイプ、給与の上限下限を条件に検索する画面を考えてみましょう。
					べたに検索条件を組み立てるとはこんな感じになるはずです。
				</p>
<div class="source"><pre>
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
StringBuilder sb = new StringBuilder(100);
boolean found = false;
List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();
if (departmentName != null) {
    sb.append(&quot;department.name = ?&quot;);
    values.add(departmentName);
    found = true;
}
if (jobTypes.length &gt; 0) {
    if (found) {
        sb.append(&quot; and &quot;);
    }
    sb.append(&quot;jobType in (&quot;);
    for (JobType jt : jobTypes) {
        sb.append(&quot;?, &quot;);
        values.add(jt);
    }
    sb.setLength(sb.length() - 2);
    sb.append(&quot;)&quot;);
    found = true;
}
if (salaryMin != null) {
    if (found) {
        sb.append(&quot; and &quot;);
    }
    sb.append(&quot;salary &gt;= ?&quot;);
    values.add(salaryMin);
    found = true;
}
if (salaryMax != null) {
    if (found) {
        sb.append(&quot; and &quot;);
    }
    sb.append(&quot;salary &lt;= ?&quot;);
    values.add(salaryMax);
    found = true;
}
jdbcManager.from(Employee.class).where(sb.toString(), values.toArray()).getResultList();
</pre>
</div>
<p>SimpleWhereを使って組み立てれば、こんなに簡単になります。</p>
<div class="source"><pre>
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
jdbcManager.from(Employee.class)
    .where(new SimpleWhere()
        .eq(&quot;department.name&quot;, departmentName)
        .in(&quot;jobType&quot;, jobTypes)
        .ge(&quot;salary&quot;, salaryMin)
        .le(&quot;salary&quot;, salaryMax))
    .getResultList();
</pre>
</div>
<p>SimpleWhereには次のメソッドがあります。</p>
<table class="bodyTable"><tbody><tr class="a"><th>メソッド</th>
<th>説明</th>
</tr>
<tr class="b"><td>
								eq(String propertyName, Object value)
							</td>
<td><code>propertyName = ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="a"><td>
								ne(String propertyName, Object value)
							</td>
<td><code>propertyName &lt;&gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>
								lt(String propertyName, Object value)
							</td>
<td><code>propertyName &lt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="a"><td>
								le(String propertyName, Object value)
							</td>
<td><code>propertyName &lt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>
								gt(String propertyName, Object value)
							</td>
<td><code>propertyName &gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="a"><td>
								ge(String propertyName, Object value)
							</td>
<td><code>propertyName &gt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>
								in(String propertyName, Object...
								values)
							</td>
<td><code>propertyName in (?, ...)</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
							</td>
</tr>
<tr class="a"><td>
								not in(String propertyName, Object...
								values)
							</td>
<td><code>
									propertyName not in (?, ...)
								</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
							</td>
</tr>
<tr class="b"><td>
								like(String propertyName, String value)
							</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
</tr>
<tr class="a"><td>
								like(String propertyName, String value,
								char escape)
							</td>
<td><code>
									propertyName like ? escape ?
								</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>
								starts(String propertyName, String
								value)
							</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
</tr>
<tr class="a"><td>
								ends(String propertyName, String value)
							</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
</tr>
<tr class="b"><td>
								contains(String propertyName, String
								value)
							</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。 valueに
								<code>'%', '_'</code>
								が含まれる場合はエスケープされます。
							</td>
</tr>
<tr class="a"><td>
								isNull(String propertyName, Boolean
								value)
							</td>
<td><code>propertyName is null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
							</td>
</tr>
<tr class="b"><td>
								isNotNull(String propertyName, Boolean
								value)
							</td>
<td><code>propertyName is not null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
							</td>
</tr>
<tr class="a"><td>excludesWhitespace()</td>
<td>valueが空白文字列の時は条件に追加されません。</td>
</tr>
</tbody></table>
<h4><a name="Mapによる指定">Mapによる指定</a>
</h4>
<p>Mapを使うと次のようになります。</p>
<div class="source"><pre>
public String departmentName;
public String[] jobTypes = new String[0];
public BigDecimal salaryMax;
public BigDecimal salaryMin;
...
Map&lt;String, Object&gt; w = new HashMap&lt;String, Object&gt;();
w.put(&quot;department.name&quot;, departmentName);
w.put(&quot;jobType_IN&quot;, jobTypes);
w.put(&quot;salary_LE&quot;, salaryMax);
w.put(&quot;salary_GE&quot;, salaryMin);
jdbcManager.from(Employee.class).where(w).getResultList();
</pre>
</div>
<p>
					マップのキーにプロパティ名_サフィックスを指定します。 サフィックスがない場合は、
					<code>_EQ</code>
					が指定されたとみなされます。
				</p>
<p>次のサフィックスを使うことができます。</p>
<table class="bodyTable"><tbody><tr class="b"><th>サフィックス</th>
<th>説明</th>
</tr>
<tr class="a"><td>_EQ</td>
<td><code>propertyName = ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>_NE</td>
<td><code>propertyName &lt;&gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="a"><td>_LT</td>
<td><code>propertyName &lt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>_LE</td>
<td><code>propertyName &lt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="a"><td>_GT</td>
<td><code>propertyName &gt; ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>_GE</td>
<td><code>propertyName &gt;= ?</code>
								の条件を追加します。valueがnullの時は追加されません。
							</td>
</tr>
<tr class="a"><td>_IN</td>
<td><code>propertyName in (?, ...)</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
								値は配列のみをサポートしています。
							</td>
</tr>
<tr class="b"><td>_NOT_IN</td>
<td><code>
									propertyName not in (?, ...)
								</code>
								の条件を追加します。 valuesの配列の長さが0の時は追加されません。
								値は配列のみをサポートしています。
							</td>
</tr>
<tr class="a"><td>_LIKE</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
							</td>
</tr>
<tr class="b"><td>_STARTS</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
</tr>
<tr class="a"><td>_ENDS</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初に自動的に
								<code>%</code>
								が追加されます。
							</td>
</tr>
<tr class="b"><td>_CONTAINS</td>
<td><code>propertyName like ?</code>
								の条件を追加します。 valueがnullの時は追加されません。
								valueの最初と最後に自動的に
								<code>%</code>
								が追加されます。
							</td>
</tr>
<tr class="a"><td>_IS_NULL</td>
<td><code>propertyName is null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
								値はBooleanのみをサポートしています。
							</td>
</tr>
<tr class="b"><td>_IS_NOT_NULL</td>
<td><code>propertyName is not null</code>
								の条件を追加します。
								valueがnullあるいはBoolean.FALSEの時は追加されません。
								値はBooleanのみをサポートしています。
							</td>
</tr>
</tbody></table>
<p>
					マップの組み立てを手動でやる必要は、基本的にありません。
					なぜなら、SimpleWhereのほうが便利だからです。 マップを使う場合は、次のように
					<code>org.seasar.framework.beans.util.Beans</code>
					を使います。
				</p>
<p><code>
						createAndCopy(Class&lt;T&gt; destClass, Object
						src)
					</code>
					の第一引数には、BeanMap.classを指定します。 BeanMapはMap&lt;String,
					Object&gt;なクラスで、 存在しないキーにアクセスすると 例外が発生します。
					キーの値は、AAA_BBBのような'_'記法の値ををaaaBbbのようなキャメル記法に
					変換したものです。 第二引数にはコピー元になるオブジェクトを指定します。
				</p>
<p><code>prefix(String prefix)</code>
					の引数には、プロパティ名のプレフィックスを指定します。
					プレフィックスを指定した場合、プレフィックスを持つプロパティだけが対象になります。
					プロパティ名がマップのキーに変換されるときに、 プレフィックスは削除され、'$'は'.'に変換されます。
				</p>
<div class="source"><pre>
public String where_department$name;
public String[] where_jobType_IN = new String[0];
public BigDecimal where_salary_LE;
public BigDecimal where_salary_GE;
...
jdbcManager.from(Employee.class)
    .where(Beans.createAndCopy(BeanMap.class, this).prefix(&quot;where_&quot;).execute())
    .getResultList();
</pre>
</div>
</div>
<div class="section"><h3><a name="ソート順"></a>
ソート順</h3>
<p>
					ソート順を指定する場合は、
					<code>orderBy()</code>
					を使います。
					<code>orderBy()</code>
					に書くことのできる条件は、SQLと同じです。
					SQLとの違いは、カラム名の代わりにプロパティ名を書くことです。
					関連先のプロパティを指定する場合は、innerJoin()/leftOuterJoin()で指定した名前.
					プロパティ名になります。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .leftOuterJoin(&quot;department&quot;)
    .orderBy(&quot;name, department.name&quot;)
    .getResultList();
</pre>
</div>
</div>
<div class="section"><h3><a name="排他制御"></a>
排他制御</h3>
<p>SELECT時にロックを取得する場合は、</p>
<ul><li><code>forUpdate()</code></li>
<li><code>
								forUpdate(String... propertyNames)
							</code></li>
<li><code>forUpdateNowait()</code></li>
<li><code>
								forUpdateNowait(String... propertyNames)
							</code></li>
<li><code>forUpdateWait(int seconds)</code></li>
<li><code>
								forUpdateWait(int seconds, String...
								propertyNames)
							</code></li>
</ul>
<p>
					を使います。 全てのRDBMSでこれらの操作が利用できるわけではありません。
					サポートされていないメソッドを呼び出すと
					<code>UnsupportedOperationException</code>
					がスローされます。
				</p>
<p><code>forUpdate(String...)</code>
					・
					<code>forUpdateNowait(String...)</code>
					の第1引数および
					<code>forUpdateWait(int, String...)</code>
					の第2引数には、ロック対象となるプロパティ名を指定します。
				</p>
<p><code>forUpdateWait(int)</code>
					・
					<code>forUpdateWait(int, String...)</code>
					の第1引数では、ロックを獲得できるまでの最大待機時間を秒単位で指定します。
				</p>
<p>
					以下の例では、EmployeeとDepartmentを結合していて、
					ロック対象のプロパティが明示されていないので、両テーブルのロックが取得されます。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .leftOuterJoin(&quot;department&quot;)
    .where(&quot;department.name = ?&quot;, deptName)
    .forUpdate()
    .getResultList();
</pre>
</div>
<p>
					以下の例でもEmployeeとDepartmentを結合していますが、
					指定されたプロパティを持つEmployeeのロックのみが取得されます。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .leftOuterJoin(&quot;department&quot;)
    .where(&quot;department.name = ?&quot;, deptName)
    .forUpdate(&quot;id&quot;)
    .getResultList();
</pre>
</div>
<p>排他制御とページングを組み合わせることはできません。</p>
</div>
<div class="section"><h3><a name="ページング"></a>
ページング</h3>
<p>
					ページングを指定する場合は、
					<code>limit(), offset()</code>
					を使います。
					<code>limit()</code>
					には、取得する行数を指定します。
					<code>offset()</code>
					には、最初に取得する行の位置を指定します。 最初の行の位置は0になります。
					ページングを指定するには、必ず
					<a href="#ソート順">ソート順</a>

					の指定も必要です。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .orderBy(&quot;name&quot;)
    .limit(100)
    .offset(10)
    .getResultList();
</pre>
</div>
<p>排他制御とページングを組み合わせることはできません。</p>
<p><code>limit()</code>
					で指定する値は問い合わせ結果の行数であり、
					<a href="#複数件検索"><code>getResultList()</code></a>

					が返すエンティティの数と一致するとは限りません。
					<code>from()</code>
					で指定したエンティティに
					<a href="s2jdbc_entity.html#一対多関連定義">1対多関連</a>

					を
					<a href="#結合">結合</a>

					した場合、
					<code>getResultList()</code>
					が返すエンティティの数は
					<code>limit()</code>
					で指定した数よりも少なくなる場合があります。
				</p>
</div>
<div class="section"><h3><a name="最大行数"></a>
最大行数</h3>
<p>
					最大行数を指定する場合は、
					<code>maxRows()</code>
					を使います。 最大行数を超える行は、通知なしに除外されます。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .maxRows(1000)
    .getResultList();
</pre>
</div>
</div>
<div class="section"><h3><a name="フェッチサイズ"></a>
フェッチサイズ</h3>
<p>
					フェッチサイズを指定する場合は、
					<code>fetchSize()</code>
					を使います。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .fetchSize(100)
    .getResultList();
</pre>
</div>
</div>
<div class="section"><h3><a name="クエリタイムアウト"></a>
クエリタイムアウト</h3>
<p>
					クエリタイムアウト(秒)を指定する場合は、
					<code>queryTimeout()</code>
					を使います。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .queryTimeout(10)
    .getResultList();
</pre>
</div>
</div>
<div class="section"><h3><a name="ヒント"></a>
ヒント</h3>
<p>
					コメントによるヒントを指定する場合は、
					<code>hint()</code>
					を使います。
				</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .hint(&quot;INDEX(Employee IDX1)&quot;)
    .getResultList();
</pre>
</div>
<p>
					ヒント中のエンティティ名(上記例では
					<code>Employee</code>
					)は別名に置換され、 Oracleでは次のようなコメントがSQLに含まれます。
				</p>
<div class="source"><pre>
/*+ INDEX(T1_ IDX1) */
</pre>
</div>
<p>ヒント中の関連プロパティ名も別名に置換されます。</p>
<div class="source"><pre>
jdbcManager.from(Employee.class)
    .leftOuterJoin(&quot;department&quot;)
    .hint(&quot;INDEX(department IDX2)&quot;)
    .getResultList();
</pre>
</div>
<p>上記の場合、 Oracleでは次のようなコメントがSQLに含まれます。</p>
<div class="source"><pre>
/*+ INDEX(T2_ IDX2) */
</pre>
</div>
<p>
					コメントによるヒントをサポートしていないRDBMSの場合、
					<code>hint()</code>
					は無視され、 SQLにコメントは付加されません。
				</p>
</div>
</div>
<div class="section"><h2><a name="挿入"></a>
挿入</h2>
<div class="section"><h3><a name="a1件挿入"></a>
1件挿入</h3>
<p>
					エンティティを挿入する場合は、
					<code>insert()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
<div class="source"><pre>
int count = jdbcManager.insert(employee).execute();
</pre>
</div>
<p>
					引数はエンティティで、戻り値は、更新した行数です。 挿入するときに、識別子を自動設定することができます。
					詳しくは、
					<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>

					を参照してください。
				</p>
<p>
					一意制約違反によりエンティティ挿入ができなかった場合は、
					<code>javax.persistence.EntityExistsException</code>
					が発生します。
				</p>
</div>
<div class="section"><h3><a name="バッチ挿入"></a>
バッチ挿入</h3>
<p>
					複数のエンティティをバッチ挿入する場合は、
					<code>insertBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager.insertBatch(employees).execute();
</pre>
</div>
<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					挿入するときに、識別子を自動設定することができます。 詳しくは、
					<a href="s2jdbc_entity.html#識別子定義">識別子定義</a>

					を参照してください。
				</p>
<p>
					一意制約違反によりエンティティを挿入ができなかった場合は、
					<code>javax.persistence.EntityExistsException</code>
					が発生します。
				</p>
</div>
<div class="section"><h3><a name="nullの項目を挿入しない"></a>
nullの項目を挿入しない</h3>
<p>
					挿入の対象からnullの項目を除外する場合は、
					<code>excludesNull()</code>
					を使います。 バッチ系の挿入は、すべてのエンティティに同じSQLを適用しなければならないので、
					nullを除外してバッチ挿入することはできません。
					なぜなら、すべてのエンティティのnullの項目が同じだとは限らないからです。
				</p>
<div class="source"><pre>
int count = jdbcManager.insert(employee).excludesNull().execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="指定したプロパティのみを挿入対象にする"></a>
指定したプロパティのみを挿入対象にする</h3>
<p>
					指定したプロパティのみを挿入対象にする場合は、
					<code>includes()</code>
					を使います。
				</p>
<div class="source"><pre>
int count = jdbcManager.insert(employee).includes(&quot;id&quot;, &quot;name&quot;).execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="指定したプロパティを挿入対象から除外する"></a>
指定したプロパティを挿入対象から除外する</h3>
<p>
					指定したプロパティを挿入対象から除外する場合は、
					<code>excludes()</code>
					を使います。
				</p>
<div class="source"><pre>
int count = jdbcManager.insert(employee).excludes(&quot;version&quot;).execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="バッチ挿入のサイズを指定する"></a>
バッチ挿入のサイズを指定する</h3>
<p>
					バッチ挿入のサイズを設定するには
					<code>batchSize()</code>
					を使います。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager.insertBatch(employees).batchSize(50).execute();
</pre>
</div>
</div>
</div>
<div class="section"><h2><a name="更新"></a>
更新</h2>
<div class="section"><h3><a name="a1件更新"></a>
1件更新</h3>
<p>
					エンティティを更新する場合は、
					<code>update()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
<div class="source"><pre>
int count = jdbcManager.update(employee).execute();
</pre>
</div>
<p>
					引数はエンティティで、戻り値は、更新した行数です。
					更新するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>

					を参照してください。
				</p>
<div style="background-color: red; font-weight: bold; font-size: larger;"><p>注意点</p>
</div><p><a href="s2jdbc_entity.html#識別子定義">識別子定義</a>

					のないエンティティは、 SQL自動生成による更新は出来ません。
				</p>
</div>
<div class="section"><h3><a name="バッチ更新"></a>
バッチ更新</h3>
<p>
					複数のエンティティをバッチ更新する場合は、
					<code>updateBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager.updateBatch(employees).execute();
</pre>
</div>
<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					更新するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>

					を参照してください。
				</p>
<div style="background-color: red; font-weight: bold; font-size: larger;"><p>注意点</p>
</div><p><a href="s2jdbc_entity.html#識別子定義">識別子定義</a>

					のないエンティティは、 SQL自動生成によるバッチ更新は出来ません。
				</p>
</div>
<div class="section"><h3><a name="バージョンプロパティを通常の更新対象にする"></a>
バージョンプロパティを通常の更新対象にする</h3>
<p>
					バージョンプロパティを通常の更新対象に含め、バージョンチェックの対象外にする場合は、
					<code>includesVersion()</code>
					を使います。
				</p>
<div class="source"><pre>
int count = jdbcManager.update(employee).includesVersion().execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="nullの項目を更新しない"></a>
nullの項目を更新しない</h3>
<p>
					更新の対象からnullの項目を除外する場合は、
					<code>excludesNull()</code>
					を使います。 バッチ系の更新は、すべてのエンティティに同じSQLを適用しなければならないので、
					nullを除外してバッチ更新することはできません。
					なぜなら、すべてのエンティティのnullの項目が同じだとは限らないからです。
				</p>
<div class="source"><pre>
int count = jdbcManager.update(employee).excludesNull().execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="指定したプロパティのみを更新対象にする"></a>
指定したプロパティのみを更新対象にする</h3>
<p>
					指定したプロパティのみを更新対象にする場合は、
					<code>includes()</code>
					を使います。
				</p>
<div class="source"><pre>
int count = jdbcManager.update(employee).includes(&quot;id&quot;, &quot;name&quot;).execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="指定したプロパティを更新対象から除外する"></a>
指定したプロパティを更新対象から除外する</h3>
<p>
					指定したプロパティを更新対象から除外する場合は、
					<code>excludes()</code>
					を使います。
				</p>
<div class="source"><pre>
int count = jdbcManager.updateBatch(employees).excludes(&quot;version&quot;).execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="変更のあったプロパティのみを更新対象にする"></a>
変更のあったプロパティのみを更新対象にする</h3>
<p>
					変更のあったプロパティのみを更新対象にする場合は、
					<code>changedFrom()</code>
					を使います。バッチ系の更新は、すべてのエンティティに同じSQLを適用しなければならないので、
					変更のあったプロパティのみをバッチ更新することはできません。
					なぜなら、変更のあったプロパティがすべてのエンティティで同じだとは限らないからです。
					最初の引数は、比較の対象にする以前のエンティティもしくはマップです。
				</p>
<div class="source"><pre>
Employee before = ...;
int count = jdbcManager.updateBatch(employees).changedFrom(before).execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="更新行数をチェックしない"></a>
更新行数をチェックしない</h3>
<p>
					バージョンによる楽観的排他制御を行う場合、 更新できた行数が0だと
					<code>
						javax.persistence.OptimisticLockException
					</code>
					が発生します。 更新行数を正しく返さないJDBCドライバを使用する場合は、
					<code>suppresOptimisticLockException()</code>
					を呼び出すことで、更新できた行数のチェックを行わなくなります。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager
    .updateBatch(employees)
    .suppresOptimisticLockException()
    .execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="バッチ更新のサイズを指定する"></a>
バッチ更新のサイズを指定する</h3>
<p>
					バッチ更新のサイズを設定するには
					<code>batchSize()</code>
					を使います。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager.updateBatch(employees).batchSize(50).execute();
</pre>
</div>
</div>
</div>
<div class="section"><h2><a name="削除"></a>
削除</h2>
<div class="section"><h3><a name="a1件削除"></a>
1件削除</h3>
<p>
					エンティティを削除する場合は、
					<code>delete()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
<div class="source"><pre>
int count = jdbcManager.delete(employee).execute();
</pre>
</div>
<p>
					引数はエンティティで、戻り値は、更新した行数です。
					削除するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>

					を参照してください。
				</p>
<div style="background-color: red; font-weight: bold; font-size: larger;"><p>注意点</p>
</div><p><a href="s2jdbc_entity.html#識別子定義">識別子定義</a>

					のないエンティティは、 SQL自動生成による削除は出来ません。
				</p>
</div>
<div class="section"><h3><a name="バッチ削除"></a>
バッチ削除</h3>
<p>
					複数のエンティティをバッチ削除する場合は、
					<code>deleteBatch()</code>
					と
					<code>execute()</code>
					を組み合わせます。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager.deleteBatch(employees).execute();
</pre>
</div>
<p>
					引数はエンティティのリストあるいは配列(可変長引数)で、戻り値は、更新した行数の配列です。
					削除するときに、バージョンによる楽観的排他制御をすることができます。 詳しくは、
					<a href="s2jdbc_entity.html#バージョン定義">バージョン定義</a>

					を参照してください。
				</p>
<div style="background-color: red; font-weight: bold; font-size: larger;"><p>注意点</p>
</div><p><a href="s2jdbc_entity.html#識別子定義">識別子定義</a>

					のないエンティティは、 SQL自動生成によるバッチ削除は出来ません。
				</p>
</div>
<div class="section"><h3><a name="バージョンをチェックしないで削除する"></a>
バージョンをチェックしないで削除する</h3>
<p>
					バージョンをチェックしないで削除する場合は、
					<code>ignoreVersion()</code>
					を使います。
				</p>
<div class="source"><pre>
int count = jdbcManager.delete(employee).ignoreVersion().execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="削除行数をチェックしない"></a>
削除行数をチェックしない</h3>
<p>
					バージョンによる楽観的排他制御を行う場合、 削除できた行数が0だと
					<code>
						javax.persistence.OptimisticLockException
					</code>
					が発生します。 削除行数を正しく返さないJDBCドライバを使用する場合は、
					<code>suppresOptimisticLockException()</code>
					を呼び出すことで、更新できた行数のチェックを行わなくなります。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager
    .deleteBatch(employees)
    .suppresOptimisticLockException()
    .execute();
</pre>
</div>
</div>
<div class="section"><h3><a name="バッチ削除のサイズを指定する"></a>
バッチ削除のサイズを指定する</h3>
<p>
					バッチ削除のサイズを設定するには
					<code>batchSize()</code>
					を使います。
				</p>
<div class="source"><pre>
int[] countArray = jdbcManager.updateDelete(employees).batchSize(50).execute();
</pre>
</div>
</div>
</div>
<div class="section"><h2><a name="ストアドの呼び出し"></a>
ストアドの呼び出し</h2>
<div class="section"><h3><a name="ストアドプロシージャの呼び出し"></a>
ストアドプロシージャの呼び出し</h3>
<p>
					ストアドプロシージャを呼び出す場合は、
					<code>call()</code>
					と
					<code>execute()</code>
					を組み合わせます。
					<code>call()</code>
					の最初の引数は、 呼び出すストアドプロシージャの名前です。
				</p>
<p>最初の例は、パラメータのない場合です。</p>
<div class="source"><pre>
jdbcManager.call(&quot;myproc&quot;).execute();
</pre>
</div>
<p>
					INのパラメータが1つだけで、そのパラメータが
					<code>null</code>
					にならない場合は、
					<code>call()</code>
					の2番目の引数で値を直接指定します。
				</p>
<div class="source"><pre>
jdbcManager.call(&quot;myproc&quot;, &quot;hoge&quot;).execute();
</pre>
</div>
<p>
					上記以外の場合は、
					<code>call()</code>
					の2番目の引数にJavaBeansを指定します。
					ストアドプロシージャを呼び出すパラメータの順番にJavaBeansのフィールドを定義します。
				</p>
<ul><li>
							フィールドにアノテーションが付けられていない場合、
							<code>IN</code>
							パラメータになります。
						</li>
<li>
							フィールドに
							<code>@Out</code>
							アノテーションが付けられている場合、
							<code>OUT</code>
							パラメータになります。
						</li>
<li>
							フィールドに
							<code>@InOut</code>
							アノテーションが付けられている場合、
							<code>INOUT</code>
							パラメータになります。
						</li>
<li>
							フィールドに
							<code>@ResultSet</code>
							アノテーションが付けられている場合、 パラメータ以外で戻される結果セットになります。
							ただし、 OracleやPostgreSQLのように、
							パラメータ以外で結果セットを返すことが出来ないRDBMSの場合は、
							<code>OUT</code>
							パラメータとして扱われます。
						</li>
<li>
							フィールドに
							<code>@Lob</code>
							が付けられている場合、 そのパラメータはLOBとして扱われます。
							<code>@Lob</code>
							アノテーションは他のアノテーションと組み合わせて使用することが出来ます。
						</li>
</ul>
<div class="source"><pre>
public class MyDto {
    public String arg1; // 第1引数 (IN)

    @Out
    public String arg2; // 第2引数 (OUT)

    @InOut
    public int arg3;    // 第3引数 (INOUT)

    @ResultSet
    public List&lt;String&gt; result; // 結果セット
}
</pre>
</div>
<div class="source"><pre>
MyDto dto = new MyDto();
dto.arg1 = &quot;hoge&quot;;
dto.arg3 = 2;
jdbcManager.call(&quot;myproc&quot;, dto).execute();
System.out.println(dto.arg2);
System.out.println(dto.arg3);
System.out.println(dto.result);
</pre>
</div>
<p>
					ストアドプロシージャが複数のカラムを持つ結果セットを返す場合は、
					対応するフィールドの型をList&lt;結果セットの行に対応するJavaBeansの型&gt;にします。
				</p>
<div class="source"><pre>
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List&lt;EmployeeDto&gt; result; // 結果セット
}
</pre>
</div>
<div class="source"><pre>
MyDto dto = new MyDto();
dto.arg1 = 1;
jdbcManager.call(&quot;myproc&quot;, dto).execute();
System.out.println(dto.result);
</pre>
</div>
<p>
					オラクルとPostgreSQLの場合は、結果セットをパラメータで受け取る必要があります。
					これらのRDBMSでは、
					<code>@ResultSet</code>
					アノテーションが付けられたパラメータは
					<code>OUT</code>
					パラメータとして扱われます。
				</p>
<div class="source"><pre>
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List&lt;EmployeeDto&gt; result; // 第2引数 (OUT)
}
</pre>
</div>
<div class="source"><pre>
MyDto dto = new MyDto();
dto.arg1 = 1;
jdbcManager.call(&quot;myproc&quot;, dto).execute();
System.out.println(dto.result);
</pre>
</div>
</div>
<div class="section"><h3><a name="ストアドファンクションの呼び出し"></a>
ストアドファンクションの呼び出し</h3>
<p>
					ストアドファンクションを呼び出す場合は、
					<code>call()</code>
					と、
					<code>getSingleResult()</code>
					または
					<code>getResultList()</code>
					を組み合わせます。
					<code>call()</code>
					の1番目の引数でストアドファンクションの戻り値の型を指定します。
					2番目の引数でストアドファンクションの名前を指定します。
				</p>
<div class="source"><pre>
String result = jdbcManager.call(String.class, &quot;myfunc&quot;)
                           .getSingleResult();
</pre>
</div>
<p>
					OracleやPostgreSQLのように、
					ストアドファンクションの戻り値で結果セットを返すことが出来る場合は
					<code>getResultList()</code>
					で結果の
					<code>List</code>
					を受け取ります。
					<code>call()</code>
					の1番目の引数で
					<code>List</code>
					の要素の型を指定します。
				</p>
<div class="source"><pre>
List&lt;String&gt; result = jdbcManager.call(String.class, &quot;myfunc&quot;)
                                 .getResultList();
</pre>
</div>
<p>
					結果セットの行が複数のカラムを持つ場合は
					<code>List</code>
					の要素をJavaBeansにします。
				</p>
<div class="source"><pre>
List&lt;MyDto&gt; result = jdbcManager.call(MyDto.class, &quot;myfunc&quot;)
                                .getResultList();
</pre>
</div>
<p>
					INのパラメータが1つだけで、そのパラメータが
					<code>null</code>
					にならない場合は、
					<code>call()</code>
					の3番目の引数で値を直接指定します。
				</p>
<div class="source"><pre>
String result = jdbcManager.call(String.class, &quot;myfunc&quot;, &quot;hoge&quot;)
                           .getSingleResult();
</pre>
</div>
<p>
					上記以外の場合は、
					<code>call()</code>
					の3番目の引数にJavaBeansを指定します。
					ストアドファンクションを呼び出すパラメータの順番にJavaBeansのフィールドを定義します。
				</p>
<ul><li>
							フィールドにアノテーションが付けられていない場合、
							<code>IN</code>
							パラメータになります。
						</li>
<li>
							フィールドに
							<code>@Out</code>
							アノテーションが付けられている場合、
							<code>OUT</code>
							パラメータになります。
						</li>
<li>
							フィールドに
							<code>@InOut</code>
							アノテーションが付けられている場合、
							<code>INOUT</code>
							パラメータになります。
						</li>
<li>
							フィールドに
							<code>@ResultSet</code>
							アノテーションが付けられている場合、 パラメータ以外で戻される結果セットになります。
							ただし、 OracleやPostgreSQLのように、
							パラメータ以外で結果セットを返すことが出来ないRDBMSの場合は、
							<code>OUT</code>
							パラメータとして扱われます。
						</li>
<li>
							フィールドに
							<code>@Lob</code>
							が付けられている場合、 そのパラメータはLOBとして扱われます。
							<code>@Lob</code>
							アノテーションは他のアノテーションと組み合わせて使用することが出来ます。
						</li>
</ul>
<div class="source"><pre>
public class MyDto {
    public String arg1; // 第1引数 (IN)

    @Out
    public String arg2; // 第2引数 (OUT)

    @InOut
    public int arg3;    // 第3引数 (INOUT)

    @ResultSet
    public List&lt;String&gt; result; // 結果セット
}
</pre>
</div>
<div class="source"><pre>
MyDto dto = new MyDto();
dto.arg1 = &quot;hoge&quot;;
dto.arg3 = 2;
String result = jdbcManager.call(String.class, &quot;myproc&quot;, dto)
                           .getSingleResult();
System.out.println(result);
System.out.println(dto.arg1);
System.out.println(dto.arg3);
System.out.println(dto.result);
</pre>
</div>
<p>
					ストアドファンクションが複数のカラムを持つ結果セットを返す場合は、
					対応するフィールドの型をList&lt;結果セットの行に対応するJavaBeansの型&gt;にします。
				</p>
<div class="source"><pre>
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List&lt;EmployeeDto&gt; result; // 結果セット
}
</pre>
</div>
<div class="source"><pre>
MyDto dto = new MyDto();
dto.arg1 = 1;
String result = jdbcManager.call(String.class, &quot;myfunc&quot;, dto)
                           .getSingleResult();
System.out.println(result);
System.out.println(dto.result);
</pre>
</div>
<p>
					オラクルとPostgreSQLの場合は、戻り値以外の結果セットをパラメータで受け取る必要があります。
					これらのRDBMSでは、
					<code>@ResultSet</code>
					アノテーションが付けられたパラメータは
					<code>OUT</code>
					パラメータとして扱われます。
				</p>
<div class="source"><pre>
public class MyDto {
    public int arg1; // 第1引数 (IN)

    @ResultSet
    public List&lt;EmployeeDto&gt; result; // 第2引数 (OUT)
}
</pre>
</div>
<div class="source"><pre>
MyDto dto = new MyDto();
dto.arg1 = 1;
String result = jdbcManager.call(String.class, &quot;myfunc&quot;, dto)
                           .getSingleResult();
System.out.println(result);
System.out.println(dto.result);
</pre>
</div>
</div>
</div>

</div><!-- article -->

</div><!-- contents_center -->

<div id="footer">
<address>  &copy; Copyright
  
          2004-2008,
    
          The Seasar Foundation and the others. All rights reserved.
      </address>
<div class="line"><span class="hide">spacer</span></div>
</div><!-- footer -->

</div><!-- wrapper -->

</body>
</html>
